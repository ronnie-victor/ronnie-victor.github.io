<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[heheheh]]></title>
    <url>%2F2018%2F11%2F18%2Fcall%E5%92%8Capply%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[深入的学习javascript语言，有一个很重要的知识点，是对call()和apply()的理解，在阅读一些开源框架源代码时，经常会看到这两个方法。在讨论这两个方法前，需要先回顾一下this的用法，因为call和apply与this有着密不可分的关系 每个函数都包含两个非继承而来的方法：call() 和 apply() 作用：在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域 一般来说，this总是指向调用某个方法的对象，但是使用aplly()和call()方法时，就会改变this的指向 一、什么是this？ 在面向对象的语言中，比如说java,this代表的是当前对象的引用。而在JavaScript中，this不是固定不变的，而是随着它的执行环境的改变而改变。this总是指向调用它所在方法的对象 this在函数中 123456function test() &#123; this.name = "Acman";&#125;test();alert(this.name); //Acmanalert(window.name); //Acman 通过结果可以看出来，函数test内部的this指向的是全局对象，为了证明例子中this是window，把代码稍作调整： 12345678var name = "Acman";function test() &#123; this.name = "TomCat"; test(); alert(this.name); //TomCat; alert(window.name); //TomCat; alert(name); //TomCat&#125; 通过结果可以证明全局的name在函数的内部被修改了，因为函数内部的this指向的window 对于全局性函数调用，函数内部的this就是指全局对象window。this是调用函数所在的对象。实际这个test()函数是由全局对象window来调用的，所以函数内部的this指的是window this在构造函数中 1234567var name = "Acman";function Person() &#123; this.name = "TomCat";&#125;var person = new Person();alert(person.name); //TomCatalert(window.name); //Acman 通过new关键字创建的一个对象实例，可以发现new关键字改变了this的指向，将这个this指向了对象person。在构造函数内部，对this.name = &quot;TomCAt&quot;进行重新赋值，并没有改变全局name的值 声明一个构造函数的实例对象时，构造函数内部的this都会指向新的实例对象，或者说构造函数内部的this指向的时新创建的对象本身 this在对象的方法中12345678var name = "Acman";var person = &#123; name: "TomCat", info: function() &#123; alert(this.name); &#125;&#125;person.info(); // TomCat 当person对象调用info()函数时，info函数内部的this指向的是person对象。即当this出现在对象的方法中时，那么该方法内部的this指向的就是这个对象本身，也就是说this指向的时调用函数的对象 二、使用call和apply由什么用？ 回顾思考一下javascript中函数几种形式的调用： 123function Person(name) &#123; this.name = name;&#125; 第一种：直接调用 Person();:此种调用方式中，函数内部的this指向window 第二种：构造函数方式调用 var person = new Person();:此种调用方式中，函数内部的this指向person 以上两种方式，函数内部的this都指向当前调用对象，只是JavaScript中函数内部的this会随着程序而指向不同的对象。使用call和apply就可以手动修改this的指向 三、由代码引发的思考 首先看两段代码： 一： 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;function info() &#123; alert(this.name + "," + this.age);&#125;var p1 = new Person("jack", 18); 问题：如何借用info函数实现对p1对象的打印？ 二：12345678910function Person(name, age) &#123; this.name = name; this.age = age;&#125;function info() &#123; alert(this.name + "," + this.age);&#125;var p1 = new Person("jack", 18);p1.show = info;p1.show(); //jack，18 通过向p1对象添加了一个show属性，show属性指向了一个函数地址，是一个函数对象，通过p1.show()实现了打印。此种方法可以实现功能，但是是通过为p1对象添加属性完成的，如果仍有类似需求，会导致p1对象的占用空间越来越大，并不优雅 针对上边的问题，本质上是想通过修改inifo函数内部this指针的问题来完成对当前对象的打印。如何在不增加属性的方式上来完成该功能，这时候就需要用到call和apply四、call和apply的使用 功能：使用指定的对象来调用当前函数 语法： call([thisObj[,arg1[,arg2[,[,.argN]]]]]) apply(thisObj[,argArray]) 说明：两个方法功能完全一样，唯一区别在于参数。对于第一个参数来说thisObj，作用相同，用作代表当前对象的对象，表示函数执行时，this指向谁；第二个参数，apply要求传入的是一个参数数组，call要求传入的是散列的参数值 这两个方法都是Function对象中的方法，因此每个定义的函数都具有该方法 call方法可以用来代替另一个对象调用一个返回广发。call方法可以将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象，如果没有提供thisObj参数，那么Global对象被用作thisObj 使用call和apply解决上面代码中的问题：123456789function Person(name, age) &#123; this.name = name; this.age = age;&#125;function info() &#123; alert(this.name + "," + this.age);&#125;var p1 = new Person("jack", 18);info.call(p1); 当在函数中调用call方法时，函数内部的this会自动指向call方法中第一个参数。123456789101112function Person() &#123; this.name = "Acman"; this.info = function() &#123; alert(this.name); &#125;&#125;function Cat() &#123; this.name = "Tom";&#125;var cat = new Cat();Person.call(cat);cat.info(); //Acman 分析上面代码，为什么会打印出”Acman”,cat对象不存在info方法。当调用call方法时，函数Person内部的this已经自动指向了cat对象，相当于给cat对象执行了下面两行代码：1234this.name = "Acman";this.info = function() &#123; alert(this.name);&#125; 重写了原来cat对象中的name属性，将”Tom”改写成了”Acman”,并且添加了一个新的info方法]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js比较两个JSON对象是否相等]]></title>
    <url>%2F2018%2F11%2F08%2Fjs%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAJSON%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[1.判断是否为对象类型123isObj = object =&gt; &#123; return object &amp;&amp; typeof(object) === 'object' &amp;&amp; Object.prototype.toString.call(object).toLowerCase() === "[object object]"; &#125;; 2.判断是否为数组123isArray = object =&gt; &#123; return object &amp;&amp; typeof(object) === 'object' &amp;&amp; object.constructor === Array;&#125;; 3.获取长度12345getLength = object =&gt; &#123; let count = 0; for(let i in object) count++; return count;&#125; 4.比较对象是否相同1234567891011121314151617181920212223242526272829303132333435363738compare = (objA, objB) =&gt; &#123; if (!isObj(objA) || !isObj(objB)) return false; //判断类型 if (getLength(objA) !== getLength(objB)) return false; //判断长度 return compareObj(objA, objB, true); //默认flag为true&#125;compareObj = (objA, objB, flag) =&gt; &#123; for (let key in objA) &#123; if (!flag) break; if (!objB.hasOwnProperty(key)) &#123; //判断objB是否存在objA的属性 flag = false; break; &#125; if (!isArray(objA[key])) &#123; //如果非数组则比较值 if (objB[key] !== objA[key]) &#123; flag = false; break; &#125; &#125; else &#123; if (!isArray(objB[key])) &#123; //A当前value为数组，B如果不是，返回false flag = false; break; &#125; let OA = objA[key], OB = objB[key]; if (OA.length !== OB.length) &#123; flag = false; break; &#125; for (let key in OA) &#123; if (!flag) &#123; break; &#125; flag = compareObj(OA[key], OB[key], flag); &#125; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>jacascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON.parse()和JSON.stringify()----进阶用法]]></title>
    <url>%2F2018%2F11%2F08%2FJSON.parse()%E5%92%8CJSON.stringify()----%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所有现代浏览器都支持JSON对象，有两个非常有用的方法来处理JSON格式的内容： JSON.parse(str(string):接受一个JSON字符串并将其转换成一个javascript对象 JSON.stringify(obj(obj):接受一个javascript对象并将其转换为一个JSON字符串 JSON.parse() JSON.parse()可以接受第二个参数，它可以在返回之前转换对象值：12345678910111213const user = &#123; name: 'John', email: 'john@awesome.com', plan: 'Pro'&#125;;const userStr = JSON.stringify(user);const newUserStr = JSON.parse(userStr, (key, value) =&gt; &#123; if (typeof value === "string") &#123; return value.toUpperCase(); &#125; return value;&#125;);console.log(newUserStr); JSON.stringify() JSON.stringify可以带两个额外的参数，第一个是替换函数，第二个间隔字符串，用作隔开返回字符串参数： value: 将要转为JSON字符串的javascript对象 replacer: 该参数可以是多种类型，如果只是一个函数，则可以改变一个javascript对象在字符串化过程中的行为，如果是一个包含String和Number对象的数组，则将它作为一个白名单。只有那些键存在于该白名单中的键值对才会被包含进最终生成的JSON字符串中。如果该参数值为null或者被省略，则所有的键值对都会被包含进最终生成的JSON字符串中 space: 该参数可以是一个String或Number对象，作用是为了在输出的JSON字符串中插入空白符来增强可读性。如果是Number对象，则表示用多少个空格来作为空白符；最大可为10，大于10的数值也取10.最小可为1，小于1的数值无效，则不会显示空白符。如果是String对象，则该字符串本身会作为空白符，字符串最长可为10个字符。超过的话会截取前10个字符。如果该参数被省略或者为null，则不会显示空白符 替换函数可以用来过滤值，因为任何返回undefined的值将不在返回的字符串中：123456789101112131415const user = &#123; id: 229, name: 'John', email: 'john@awesome.com'&#125;;function replacer(key, value) &#123; console.log(typeof value); if (key === 'email')&#123; return undefined; &#125; return value;&#125;const userStr = JSON.stringify(user, replacer);//"&#123;"id":229,"name":"John"&#125;" 传入一个间隔参数的示例：1234567891011const user = &#123; name: 'John', email: 'john@awesome.com', plan: 'Pro'&#125;;const userStr = JSON.stringify(user, null, '...');// "&#123;// ..."name": "John",// ..."email": "john@awesome.com",// ..."plan": "Pro"// &#125;" toJSON方法 如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用toJSON方法后的返回值会被序列化： 12345678var obj = &#123; foo: 'foo', toJSON: function() &#123; return 'bar'; &#125;&#125;JSON.stringify(obj); // "bar"JSON.stringify(&#123;x: obj&#125;); //"&#123;"x": "bar"&#125;" 利用toJSON方法，可以修改对象转换成JSON的默认行为 用JSON.stringify来格式化对象 格式化复杂对象： 12345678var censor = function(key, value) &#123; if(typeof value === 'function') &#123; return Function.prototype.toString.call(value); &#125; return value;&#125;var foo = &#123;bar: 1, baz: 3, o: &#123;name: 'johnny', age: 21, info: &#123;sex: "男", getSex: function() &#123;return 'sex';&#125;&#125;&#125;&#125;console.log(JSON.stringify(foo, censor, 4)); 实际返回的字符串如下： 123456789101112&#123; "bar": 1, "baz": 3, "o": &#123; "name": "johnny", "age": 21, "info": &#123; "sex": "男", "getSex": "function() &#123;return 'sex';&#125;" &#125; &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2018%2F11%2F07%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[能够扩展和收缩 flex 容器内的元素，以最大限度地填充可用空间。与以前布局方式（如 table 布局和浮动元素内嵌块元素）相比，Flexbox 是一个更强大的方式 在不同方向排列元素 重新排列元素的显示顺序 更改元素的对齐方式 动态地将元素装入容器浏览器支持 Flexbox 的情况：术语 在 Flexbox 模型中，有三个核心概念： flex 项，需要布局的元素 flex 容器，其包含 flex 项 排列方向（direction），这决定了 flex 项的布局方向基础 创建一个flex容器html:1234&lt;div class="flex[-container"&gt; &lt;div class="flex-item"&gt;1&lt;/div&gt; &lt;div class="flex-item"&gt;2&lt;/div&gt;&lt;/div&gt; css:123.flex-container &#123; display: flex;&#125; 创建一个 flex 容器，只需要将一个 display: flex 属性添加到一个元素上。默认情况下，所有的直接子元素都被认为是 flex 项，并从左到右依次排列在一行中。如果 flex 项的宽度总和大于容器，那么 flex 项将按比例缩小，直到它们适应 flex 容器宽度 将flex项排成一列 1234.flex-container &#123;display: flex;flex-direction: column;&#125; 可以通过(在 flex 容器中)设置 flex-direction: column 使 flex 项垂直布局。也可以通过设置 flex-direction: column-reverse 或 flex-direction: row-reverse来使 flex 项以相反的顺序排列。 靠右对齐的 flex 项 1234.flex-container &#123;display: flex;justify-content: flex-end;&#125; 每个 Flexbox 模型都有 flex 方向（主轴）。justify-content 用于指定 flex 项在 flex 方向（direction）上的对齐位置。 居中对齐的 flex 项 1234.flex-container &#123;display: flex;justify-content: center;&#125; 铺开的 flex 项 可以通过使用以下justify-content属性的三个间距值之一来指定容器中 flex 项之间应显示多少空间： space-evenly : flex 容器起始边缘和第一个 flex 项之间的间距和每个相邻 flex 项之间的间距是相等。 space-between : 任何两个相邻 flex 项之间的间距是相同的，但不一定等于第一个/最后一个 flex 项与 flex 容器边缘之间的间距;起始边缘和第一个项目之间的间距和末端边缘和最后一个项目之间的间距是相等的。 space-around : flex 容器中的每个 flex 项的每一侧间距都是相等的。请注意，这意味着两个相邻 flex 项之间的空间将是第一个/最后一个 flex 项与其最近边缘之间的空间的两倍。 justify-content 属性值的表现，如图： flex 项在交叉轴上的对齐 12345.flex-container &#123;display: flex;justify-content: center;align-items: center;&#125; 通过设置 justify-content:center和align-items:center，可以使 flex 项水平和垂直放置在 flex 容器的中心。 对齐某个特定的 flex 项 1234567.flex-container &#123;display: flex;align-items: center;&#125;.flex-bottom &#123;align-self: flex-end;&#125; 可以在某个特定的 flex 项上使用 align-self CSS 属性，来使该特定的 flex 项与容器中的其他 flex 项进行对齐。 允许 flex 项多行/列排列 1234.flex-container &#123;display: flex;flex-wrap: wrap;&#125; 通过添加flex-wrap: wrap ，可以将溢出容器的 flex 项将被排列到另一行/列中 flex 项反向多行/列排列1234.flex-container &#123;display: flex;flex-wrap: wrap-reverse;&#125; flex项指定位置 order :子元素排列的位置默认是按照html先后顺序来排列的，html结构谁在前面默认就排列在前面；order的作用就是改变子元素排列顺序， order：默认（0） 值越小越靠前123.inner:nth-child(5)&#123; order: -1;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用简写技巧]]></title>
    <url>%2F2018%2F11%2F06%2Fjavascript%E5%B8%B8%E7%94%A8%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、三目运算符原代码：1234567const x = 20;let answer;if (x &gt; 10) &#123; answer = 'greater than 10';&#125; else &#123; answer = 'less than 10';&#125; 简写代码：1let answer = x &gt; 10 ? 'greater than 10' : 'less than 10'; 2、循环语句原代码：1for (let i = 0;i &lt; allImgs.length; i ++) 简写代码：1for (let index of allImgs) 遍历数组forEach简写示例：1234let logArrayElements = (element, index, array) =&gt; &#123; console.log(`a[$&#123;index&#125;] = $&#123;element&#125;`);&#125;[2, 3, 4].forEach(logArrayElements); 3、声明变量 在函数开始前，对变量赋值是一种好的习惯。声明多个变量时：123let x;let y;let z = 1; 简写代码：1let x, y, z = 3; 4、if语句 使用if进行基本判断时，可以省略赋值运算符1if (like === true) 简写代码：1if (like) 5、十进制数 可以用科学计数法来替代较大的数值，将10000000简写为1e7：1for (let i = 0; i &lt; 10000000; i++) 简写代码：1for (let i = 0; i &lt; 1e7; i++) 6、多行字符串原代码：1alert("你好，\n 我叫\n Olive"); 简写代码：123alert(`你好我叫olive`); 7、变量赋值 将变量值赋给另外一个变量，首先要判断原值不是null、未定义或者空值原代码：123if (variable1 !== null || variable1 !== underfined || variable1 !== '')&#123; let variable2 = variable1;&#125; 简写代码：1const variable2 = variable1 || 'new'; 测试代码：123456let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // prints truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // prints foo 8、默认值赋值 如果预期参数是null或者undefined，可以使用简短的逻辑运算符；原代码：123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = 'localhost';&#125; 简写代码：1let dbHost = process.env.DB_HOST || 'localhost'; 9、对象属性 ES6提供了简单方法分配对象属性。如果属性名与key名相同，可使用简写原代码：1const obj = &#123;x: x, y: y&#125;; 简写代码：1const obj = &#123;x, y&#125;; 10、箭头函数 如果将原始函数嵌套在其它函数中进行调用时，函数会变得冗长混乱原代码：1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125; setTimeout(function() &#123; console.log('Loaded');&#125;, 2000); list.forEach(function(item) &#123; console.log(item);&#125;); 简写代码：123sayHello = (name) =&gt; console.log('Hello', name);setTimeout( () =&gt; console.log('Loaded'), 2000);list.forEach( item =&gt; console.log(item)); 11、隐式返回值 返回值通常用来返回函数最终结果的关键字，只有一个语句的箭头函数，可以隐式返回结果。（函数必须省略{}，以便省略return关键字）原代码：123function calcCircumference(diameter) &#123; return Math.PI * diameter;&#125; 简写代码：123calcCircumference = diameter =&gt; ( Math.PI * diameter) 12、默认参数值 之前定义默认参数值都是使用if方式，ES6规定了可以在函数中定义参数默认值原代码：123456789function volume(l, w, h) &#123; if (w === undefined) &#123; w = 3; &#125; if (h === undefined) &#123; h = 4; &#125; return l * w * h;&#125; 简写代码：1234function volume(l, w = 3, h = 4) &#123; return l * w * h;&#125;volume(2) // output: 24 13、模板字符串 之前使用+将多个变量转换为字符串原代码：12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; 简写代码：12const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125; . `const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 14、解构赋值 解构赋值时一种表达式，用于从数组或对象中快速提取属性值，并赋给定义的变量原代码：12345678const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; 简写代码：12import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 自定义变量名：1const &#123; store, form, loading, errors, entity:contact &#125; = this.props; 15、展开运算符 使用展开运算符可以替换某些数组函数原代码：123456//joining arraysconst old = [1, 2, 3];const nums = [4, 5, 6].concat(old);// cloning arraysconst arr = [1, 2, 3, 4, 5, 6];const arr2 = arr.slice(); 简写代码： 123456 //joining arraysconst old = [1, 2, 3];const nums = [4, 5, 6, ...old];// cloning arraysconst arr = [1, 2, 3, 4, 5, 6];const arr2 = [...arr]; 可以使用扩展运算符在任何一个数组中插入另一个数组 12const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6]; 可以将展开运算符和 ES6 解构符号结合使用 1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 16、强制参数 默认情况下，如果不向函数参数传值，那么 JavaScript 会将函数参数设置为未定义。其它一些语言则会发出警告或错误。要执行参数分配，可以使用if语句抛出未定义的错误，或者可以利用“强制参数”原代码：123456function foo(bar) &#123; if(bar === undefined) &#123; throw new Error('Missing parameter!'); &#125; return bar;&#125; 简写代码：123456mandatory = () =&gt; &#123; throw new Error('Missing parameter!');&#125;foo = (bar = mandatory()) =&gt; &#123; return bar;&#125; 16、Array.find原代码：123456789101112const pets = [ &#123;type: 'Dog', name: 'Max'&#125;, &#123;type: 'Cat', name: 'Cat'&#125;, &#123;type: 'Dog', name: 'Tom'&#125;]function findDog(name) &#123; for(let i = 0; i &lt; pets.length; i++)&#123; if (pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; 简写代码：1pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy'); 17、Object [key] 通常将 foo.bar 写成 foo [‘bar’] 是一种常见的做法，这种做法构成了编写可重用代码的基础原代码： 12345678function validate(values) &#123; if(!values.first) return false; if(!values.last) return false; return true;&#125;console.log(validate(&#123;first:'Bruce',last:'Wayne'&#125;)); // true 上面的函数可以完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。可以构建一个在运行时配置的通用验证函数 1234567891011121314151617181920212223// object validation rulesconst schema = &#123; first: &#123; required:true &#125;, last: &#123; required:true &#125;&#125; // universal validation functionconst validate = (schema, values) =&gt; &#123; for(field in schema) &#123; if(schema[field].required) &#123; if(!values[field]) &#123; return false; &#125; &#125; &#125; return true;&#125;console.log(validate(schema, &#123;first:'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first:'Bruce',last:'Wayne'&#125;)); // true 后续补充。。。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid快速入门]]></title>
    <url>%2F2018%2F10%2F30%2FCSS%20Grid%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Grid布局是网站设计的基础，CSS Grid是创建网格布局强大和简单的工具 CSS Grid已获得主流浏览器(Safari, Firefox, Chrome, Edge)的原生支持Grid布局CSS Grid布局由两个核心部分组成：wrapper(Parent Element)和item(Child Element)html示例：12345678&lt;div class="wrapper"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;&lt;div&gt;6&lt;/div&gt;&lt;/div&gt; css示例： 要将wrapper元素变为grid，只需要display: grid;即可123.wrapper&#123;display: grid;&#125; 由于还未进行任何操作，它会将六个div堆叠在一起： Columns 和 Rows 要使其成为二维的grid容器，需要设置列和行的属性，需要使用到grid-template-column和grid-template-row示例：12345.wrapper&#123;display: grid;grid-template-columns: 100px 100px 200px;grid-template-rows: 50px 50px;&#125; 放置items 给每个items(Child Element)加上class示例： 12345678&lt;div class="wrapper"&gt;&lt;div class="item1"&gt;1&lt;/div&gt;&lt;div class="item2"&gt;2&lt;/div&gt;&lt;div class="item3"&gt;3&lt;/div&gt;&lt;div class="item4"&gt;4&lt;/div&gt;&lt;div class="item5"&gt;5&lt;/div&gt;&lt;div class="item6"&gt;6&lt;/div&gt;&lt;/div&gt; 创建一个3*2的grid布局： 12345.wrapper&#123;display: grid;grid-template-columns: 100px 100px 100px;grid-template-rows: 100px 100px;&#125; 要定位和调整items(Child Element)，需要使用到grid-column 和 grid-row示例： 1234.item1&#123;grid-column-start: 1;grid-column-end: 4;&#125; item1从第一条网格线开始到第四条网格线结束，将独占一行 网格线图： 简写方法: 123.item1&#123;grid-column: 1 / 4;&#125; 重新排列其它items元素： 123456789101112.item1 &#123;grid-column-start: 1;grid-column-end: 3;&#125;.item3 &#123;grid-row-start: 2;grid-row-end: 4;&#125;.item4 &#123;grid-column-start: 2;grid-column-end: 4;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F10%2F20%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown是一种纯文本格式的标记语言，目标是为了实现易读易写。 一、标题语法：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 二、字体语法：1234**加粗***斜体****斜体加粗***~~删除线~~ 示例：加粗斜体斜体加粗删除线 三、引用语法：123&gt;引用&gt;&gt;引用嵌套&gt;&gt;&gt;引用嵌套 示例： 引用 引用嵌套 引用嵌套 四、分割线语法：12***--- 示例： 五、图片语法：1![图片alt](图片地址 "图片title") 示例： 六、超链接语法：1[超链接名](超链接地址 "超链接title") 示例：Ronie’s Blog 七、列表语法： 无序列表： 123* 列表一- 列表二+ 列表三 有序列表： 1231. 列表12. 列表23. 列表3 列表嵌套 12345678* 列表一 1. 列表1 2. 列表2 3. 列表3* 列表二 * 列表一 * 列表二 * 列表三 示例： 列表一 列表二 列表三 列表1 列表2 列表3 列表一 列表1 列表2 列表3 列表二 列表一 列表二 列表三八、表格语法：12345| 表头 | 表头 | 表头 || - | :-: | -: || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 || 内容 |内容 | 内容 | 示例： 表头 表头 表头 内容 内容 内容 内容 内容 内容 内容 内容 内容 九、代码语法： 单行代码; 1`代码内容` 代码块 12345(```language) 代码。。。 代码。。。 代码。。。(```) 示例： 代码123代码。。。代码。。。代码。。。]]></content>
      <categories>
        <category>grammar</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
